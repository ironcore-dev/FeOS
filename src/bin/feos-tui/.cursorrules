# FeOS TUI Development Rules

## Project Overview
This is the Terminal User Interface (TUI) for FeOS, built with Rust and ratatui. The TUI provides a comprehensive interface for managing FeOS containers, virtual machines, isolated pods, and system monitoring with a modern, modular architecture.

## Architecture Guidelines

### Module Structure
- **`main.rs`**: Entry point and main application loop only (test functionality removed)
- **`app.rs`**: Application state management and business logic
- **`events.rs`**: Keyboard input handling and navigation logic
- **`terminal.rs`**: Terminal setup/teardown and low-level terminal operations
- **`mock_data.rs`**: Centralized mock data generation with shared container log functions
- **`ui/`**: All UI rendering logic, organized by concern:
  - **`mod.rs`**: Main UI coordination and layout
  - **`components.rs`**: Reusable UI components (header, help modal, system actions)
  - **`dashboard.rs`**: Dashboard view rendering
  - **`log_components.rs`**: Shared log rendering components with scrolling and wrapping
  - **`utils.rs`**: Common formatting utilities (memory, CPU, uptime)
  - **`views/`**: Specific view implementations (VMs, containers, isolated pods, logs)

### Design Principles
1. **Separation of Concerns**: Keep UI rendering, business logic, and data separate
2. **Single Responsibility**: Each module should have one clear purpose
3. **Modular Views**: New views should be easy to add without modifying existing code
4. **Component Reuse**: UI components should be reusable across different views
5. **DRY (Don't Repeat Yourself)**: Shared components eliminate code duplication
6. **Consistent Log Display**: All logs show chronological order (old to new) with bounded scrolling
7. **Error Handling**: Use `color-eyre` for comprehensive error handling

## Coding Standards

### Rust Style
- Follow standard Rust naming conventions (snake_case for functions/variables, PascalCase for types)
- Use `#[derive(Debug, Clone, Copy, PartialEq)]` for enums when appropriate
- Prefer explicit type annotations for public APIs
- Use `pub` visibility only when necessary for module boundaries

### UI Development
- Always use `ratatui` widgets and avoid custom drawing when possible
- Use consistent color schemes:
  - **Cyan**: Headers and titles
  - **Yellow**: Highlighted/selected items
  - **Green**: Success states, RAM usage
  - **Blue**: CPU usage, sparklines
  - **Red**: Error states, stopped VMs
  - **Gray**: Placeholder text, help text
- Maintain consistent spacing and layout constraints
- Use `Block::default().borders(Borders::ALL).title("Title")` for consistent styling

### State Management
- Keep all mutable state in the `App` struct
- Use private fields with public accessors when needed
- Implement `Default` for structs that need initialization
- Use `Instant` for time-based operations, not system time

### Event Handling
- Handle all keyboard events in the `events.rs` module
- Use clear, intuitive key bindings:
  - `q`: Quit application
  - `d`, `v`, `l`: Direct navigation to Dashboard, VMs, Logs
  - `←`, `→`: Tab navigation
  - `↑`, `↓`: List navigation (when implemented)
  - `Enter`: Primary action
  - `Esc`: Cancel/back

## Mock Data Guidelines

### Dynamic Behavior
- Simulate realistic data changes over time
- Use atomic counters for thread-safe state updates
- Implement different update frequencies for different data types:
  - **Polling data** (host info, VM status): Every 2 seconds
  - **Streaming data** (logs): Every 3 seconds
- Keep log history bounded (max 50 entries) to prevent memory growth

### Data Realism
- VM status transitions should follow realistic patterns
- Resource usage should vary within reasonable bounds
- Log messages should be realistic and varied
- Network interfaces should have valid MAC/PCI addresses

## Testing Requirements

### Unit Tests
- Test all utility functions (formatting, calculations)
- Test mock data generation and validation
- Test state transitions and business logic
- Maintain test coverage for all public APIs

### Integration Testing
- Use `--test` mode for non-interactive testing
- Test dynamic data updates and timing
- Verify UI components render without panics
- Test keyboard navigation and state changes

### Development Testing
Use `cargo run --bin feos-tui` for interactive testing with mock data during development.

## Error Handling

### Terminal Safety
- Always restore terminal state on panic or error
- Use `color-eyre` for better error messages and stack traces
- Set up panic hooks to ensure terminal cleanup
- Handle all `Result` types explicitly

### Graceful Degradation
- Continue operation when non-critical errors occur
- Log errors appropriately without crashing
- Provide meaningful error messages to users
- Validate input data before processing

## Performance Guidelines

### Rendering Efficiency
- Avoid unnecessary re-renders by checking if data has changed
- Use efficient data structures for large lists
- Minimize string allocations in hot paths
- Cache computed values when appropriate

### Memory Management
- Bound collection sizes (logs, history data)
- Use `Vec::with_capacity()` when size is known
- Prefer borrowing over cloning when possible
- Clean up resources properly

## Shared Components

### Log Components (`ui/log_components.rs`)
The TUI provides shared log rendering components to ensure consistency across all views:

#### Usage Patterns
```rust
// For compact log display (dashboard, sidebar logs)
log_components::render_compact_log_view(f, area, logs, "Title", kernel_mode);

// For full-screen log display with scrolling and wrapping
let config = LogConfig {
    title: "Log Title",
    scroll_offset: app.scroll_offset,
    line_wrap: app.line_wrap,
    kernel_mode: false, // true for kernel logs (blue INFO), false for app logs (green INFO)
};
log_components::render_log_view(f, area, logs, config);
```

#### Features
- **Chronological ordering**: All logs display from old (top) to new (bottom)
- **Bounded scrolling**: Prevents scrolling past available log content
- **Line wrapping**: Toggle between wrapped and truncated display modes
- **Color coding**: Level-based coloring with kernel vs application differentiation
- **Consistent formatting**: Unified timestamp and message formatting

### Utilities (`ui/utils.rs`)
Shared formatting functions eliminate code duplication:

```rust
use super::super::utils;

// Format memory limits with "No limit" for zero values
let memory_str = utils::format_memory_limit(container.memory_limit);

// Format CPU limits with "No limit" for zero values  
let cpu_str = utils::format_cpu_limit(container.cpu_limit);

// Format uptime from creation timestamp
let uptime_str = utils::format_uptime_from_created(container.created);
```

## Future Development

### Adding New Views
1. Create new file in `ui/` directory (e.g., `ui/settings.rs`)
2. Add view enum variant to `app.rs`
3. Add rendering call to `ui/mod.rs`
4. Add keyboard shortcut to `events.rs`
5. Update footer help text in `ui/components.rs`

### Adding New Components
1. Add to `ui/components.rs` if reusable across views
2. Add to specific view file if view-specific
3. Follow consistent styling patterns
4. Include proper error handling

### Mock Data Extensions
1. Add new data types to `mock_data.rs`
2. Implement realistic generation patterns
3. Add appropriate unit tests
4. Update dynamic simulation if needed

## Dependencies

### Core Dependencies
- **`ratatui`**: TUI framework - prefer latest stable version
- **`crossterm`**: Cross-platform terminal manipulation
- **`color-eyre`**: Enhanced error handling and reporting

### Development Dependencies
- **`serial_test`**: For tests that need sequential execution
- Standard Rust testing framework for unit tests

## Documentation

### Code Comments
- Document complex algorithms and business logic
- Explain non-obvious design decisions
- Use doc comments (`///`) for public APIs
- Keep comments up-to-date with code changes

### README Updates
- Keep feature lists current
- Document new keyboard shortcuts
- Update screenshots when UI changes significantly
- Maintain installation and usage instructions

## Git Workflow

### Commit Messages
- Use conventional commit format: `feat:`, `fix:`, `refactor:`, etc.
- Be specific about what changed and why
- Reference issues when applicable

### Branch Strategy
- Create feature branches for new views or major changes
- Keep commits focused and atomic
- Test thoroughly before merging

Remember: The TUI should feel responsive, intuitive, and professional. Always prioritize user experience and code maintainability. 